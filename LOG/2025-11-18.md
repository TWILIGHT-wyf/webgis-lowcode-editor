# 2025-11-18 开发日志

## 1. 动画功能实现原理

### 核心思路

- 每个组件在数据模型中增加 `animation` 字段，包含动画配置：
  ```typescript
  animation?: {
    name: string           // 动画名称（用户可读）
    class: string          // CSS 动画类名
    duration?: number      // 持续时间（秒）
    delay?: number         // 延迟（秒）
    iterationCount?: number | 'infinite'  // 重复次数
    timingFunction?: string  // 缓动函数
    trigger?: 'load' | 'hover' | 'click'  // 触发方式
  }
  ```

### 实现细节

- **CSS 动画库**：在 `src/styles/animations.css` 中预定义一组 CSS `@keyframes` 动画（如淡入、滑入、旋转等）
- **动画应用**：
  - `shape.vue` 的 `.shape-box` 容器添加动态 class 和 style：
    - `:class="contentClass"`：从 `animation.class` 读取 CSS 类名
    - `:style="contentStyle"`：根据 `animation` 配置动态生成 `animationDuration`、`animationTimingFunction`、`animationIterationCount` 等内联样式
  - 这样动画会应用到整个形状容器（包括内容 + 边框 + 缩放手柄），实现统一动效
- **触发机制**：
  - `load`：组件挂载时自动播放（默认行为）
  - `hover`/`click`：通过 CSS 伪类 `:hover` 或 JS 事件监听实现
- **属性面板**：用户可在右侧属性面板中选择动画、配置参数，实时预览效果

---

## 2. 批量复制/剪切/删除/粘贴功能实现原理

### 2.1 多选机制

- **Ctrl+点击多选**：`toggleSelect(id, ctrlKey)` 函数检测 Ctrl 键，切换组件选中状态，维护 `selectedIds` 数组
- **框选**：（待实现）鼠标拖拽矩形框选多个组件
- **选中状态存储**：
  - `selectComponent`：主选中对象（单选或多选时的第一个）
  - `selectedIds`：所有选中组件 ID 的数组

### 2.2 批量操作实现

#### 复制 (Copy)

```typescript
function copyMultiple(ids: string[]) {
  const comps = resolveCopyTargets(ids) // 去重并保序
  clipboard.value = comps.map((c) => snapshotWithoutGrouping(c)) // 深拷贝快照
}
```

- **去重保序**：`resolveCopyTargets` 确保同一组件只记录一次
- **快照克隆**：`snapshotWithoutGrouping` 通过 JSON 深拷贝并移除 `groupId`/`children` 字段，避免关联数据污染

#### 剪切 (Cut)

```typescript
function cutMultiple(ids: string[]) {
  copyMultiple(ids) // 先复制
  removeMultipleComponents(ids) // 再删除原对象
}
```

#### 粘贴 (Paste)

```typescript
function paste(position: { x; y }) {
  if (clipboard.length === 1) {
    // 单个粘贴：直接放置在鼠标位置
  } else {
    // 多个粘贴：
    // 1. 以第一个组件为锚点，记录其他组件的相对偏移
    const anchor = snaps[0]
    snaps.forEach((comp, index) => {
      const offsetX = comp.position.x - anchor.position.x
      const offsetY = comp.position.y - anchor.position.y
      const newPos = { x: position.x + offsetX, y: position.y + offsetY }
      // 2. 创建新组件，保持相对布局
      const newComp = { ...comp, id: newId, position: newPos }
      componentStore.push(newComp)
    })
    // 3. 【关键修复】：下一帧矫正位置，避免外部副作用拉齐坐标
    setTimeout(() => {
      newIds.forEach((id) => {
        const comp = find(id)
        if (comp.position !== expected) comp.position = expected
      })
    }, 0)
  }
}
```

**核心问题与修复**：

- **问题根因**：粘贴后多个组件位置被外部副作用（可能是响应式更新或 watch）拉到同一点，导致"叠在一起"
- **修复方案**：
  1. 在推入 store 前记录每个组件的"期望位置"快照 `expectedPos`
  2. 推入 store 并触发 `selectMultiple(newIds)` 后
  3. 在下一帧 `setTimeout(0)` 中统一校验：若位置被改写则强制还原期望值
  - 这样既不阻塞正常流程，又能规避意外的位置同步逻辑

#### 删除 (Delete)

```typescript
function removeMultipleComponents(ids: string[]) {
  ids.forEach((id) => {
    const index = componentStore.findIndex((c) => c.id === id)
    if (index > -1) componentStore.splice(index, 1)
  })
  clearSelection()
}
```

---

## 3. 组合功能实现原理

### 3.1 数据模型设计

- **组合容器**：
  - 类型标记：`type: 'Group'`
  - 包围盒：`position`/`size` 覆盖所有成员的边界框
  - 子组件列表：`children: string[]` 存储成员 ID
- **成员组件**：
  - 所属标记：`groupId: string` 指向父组合 ID
  - 位置保留：成员位置为**绝对坐标**（相对于画布），非相对组合

### 3.2 组合操作

#### 创建组合 (Group)

```typescript
function groupComponents(ids: string[]) {
  // 1. 计算成员的包围盒（边界框）
  const minX = Math.min(...members.map((c) => c.position.x))
  const maxX = Math.max(...members.map((c) => c.position.x + c.size.width))
  // ...同理 minY/maxY

  // 2. 创建 Group 组件
  const groupComponent = {
    id: groupId,
    type: 'Group',
    position: { x: minX, y: minY },
    size: { width: maxX - minX, height: maxY - minY },
    // 【关键】：z-index 设为成员最小值-1，确保组合在成员下方
    zindex: Math.min(...members.map((c) => c.zindex)) - 1,
    children: [...ids],
  }

  // 3. 标记成员归属，保持其绝对位置不变
  members.forEach((comp) => (comp.groupId = groupId))

  componentStore.push(groupComponent)
}
```

#### 取消组合 (Ungroup)

```typescript
function ungroupComponents(groupId: string) {
  // 1. 记录子组件期望位置快照
  const expectedPos = {}
  group.children.forEach((childId) => {
    const child = find(childId)
    expectedPos[childId] = { ...child.position }
  })

  // 2. 移除成员的 groupId 标记
  group.children.forEach((childId) => {
    const child = find(childId)
    delete child.groupId
  })

  // 3. 删除 Group 容器
  componentStore.splice(groupIndex, 1)

  // 4. 选中原成员
  selectMultiple(group.children)

  // 5. 【关键修复】：下一帧矫正位置（同粘贴修复原理）
  setTimeout(() => {
    group.children.forEach((childId) => {
      const child = find(childId)
      if (child.position !== expectedPos[childId]) {
        child.position = expectedPos[childId]
      }
    })
  }, 0)
}
```

### 3.3 组合交互优化

#### 子组件可选中 + 空白处选组合

- **实现方案**：
  1. **z-index 分层**：组合 z-index 低于成员，点击优先命中子组件
  2. **空白区域命中测试**：

     ```typescript
     // 在 canvasBoard.vue 的画布点击处理中
     const stageX = (e.clientX - rect.left - panX) / scale
     const stageY = (e.clientY - rect.top - panY) / scale

     const groups = componentStore.value
       .filter((c) => c.type === 'Group')
       .filter(
         (g) =>
           stageX >= g.position.x &&
           stageX <= g.position.x + g.size.width &&
           stageY >= g.position.y &&
           stageY <= g.position.y + g.size.height,
       )
       .sort((a, b) => a.zindex - b.zindex)

     const hit = groups[groups.length - 1] // 取最上层组合
     if (hit) selectedId(hit.id)
     else clearSelection()
     ```

  3. **效果**：
     - 点击子组件 → 直接选中子组件，显示其 shape，可独立操作
     - 点击组内空白 → 命中测试命中 Group，选中组合，可整体移动/缩放

#### 组合拖拽与缩放

- **拖拽组合**：
  - 在 `shape.ts` 的 `dragCallback` 中检测 `comp.type === 'Group'`
  - 记录拖拽前子组件位置快照 `childrenStartPos`
  - 拖拽过程中同步偏移所有子组件：
    ```typescript
    const actualDx = newPos.x - dragStartPos.x
    comp.children.forEach((childId) => {
      const child = find(childId)
      child.position.x = childrenStartPos[childId].x + actualDx
      child.position.y = childrenStartPos[childId].y + actualDy
    })
    ```
- **缩放组合**：
  - 记录初始状态 `childrenStartState`（位置 + 尺寸）
  - 计算缩放比例 `scaleX = newWidth / startWidth`
  - 同步缩放子组件：
    ```typescript
    const relX = childStart.position.x - groupStart.x
    child.position.x = newGroupX + relX * scaleX
    child.size.width = childStart.width * scaleX
    ```

---

## 4. 后退/前进（撤销/重做）功能实现原理

### 核心数据结构

- **快照对象**：对 `componentStore`（组件数组）做 JSON 深拷贝，保证与响应式源彻底隔离。
- **历史栈/未来栈**：`history: T[][]`、`future: T[][]` 分别记录撤销与重做链路。

### API 设计（src/stores/componentOps/history.ts）

- `commit(force?: boolean)`: 生成快照并入栈；相同序列化内容会被跳过（去重），`force=true` 强制入栈。
- `undo()/redo()`：从 `history/future` 弹栈/入栈并应用快照。
- `canUndo()/canRedo()`：基于栈长度判断可用性，供 UI 禁用按钮。
- `commitDebounced/commitThrottled`：分别用于“移动/旋转/缩放组件”的防抖提交与“画布缩放”的节流提交。
- `init()`：初始化历史，记录初始空白状态（等价 `commit(true)`).

示例：

```ts
// component.ts 内部
const { commit, undo, redo, canUndo, canRedo, commitDebounced, commitThrottled, init } =
  createHistory(componentStore)
init()

// 拖拽更新位置/尺寸/旋转时：
updateComponentPosition(pos); commitDebounced()
updateComponentSize(size);   commitDebounced()
updateComponentRotation(r);  commitDebounced()

// 重要离散操作：
addComponent(...);      commit()
removeComponent(id);    commit()
paste(mousePos);        // 粘贴后下一帧位置矫正，再补一次 commit()
groupComponents(ids);   commit()
ungroupComponents(id);  // 取消组后下一帧矫正，再补一次 commit()
```

### UI 绑定（header.vue）

- 左上角按钮：
  - 后退：`@click="undo" :disabled="!canUndoRef"`
  - 前进：`@click="redo" :disabled="!canRedoRef"`
- 计算属性：`canUndoRef = computed(() => canUndo())`、`canRedoRef = computed(() => canRedo())`。
- 撤销/重做后会清空当前选择，避免 UI 与状态不一致。

### 提交策略补充

- 去重策略：同一状态的连续 `commit()` 不入栈（通过序列化字符串对比）。
- 粘贴/取消组合：存在外部副作用可能篡改位置，采用“下一帧矫正 + 二次提交”的模式确保历史正确。
- 可选增强（未启用）：“时间窗口合并”策略（如 500ms 内的连续 `commit()` 合并为一个历史点），可在 `createHistory()` 中加 `mergeWindow` 参数实现。

### 边界与扩展

- 当前快照仅覆盖组件集合，不包含画布缩放；如需撤销缩放，可把 `scale` 一并纳入快照或在缩放处调用 `commitThrottled()`。
- 快照为深拷贝，体积与组件数量成正比；必要时可考虑差量历史或压缩策略。

---

## 关键技术点总结

1. **深拷贝与快照**：复制粘贴、组合操作都用 `JSON.parse(JSON.stringify())` 避免引用污染
2. **响应式副作用修复**：粘贴/取消组合后，用 `setTimeout(0)` 下一帧矫正位置，规避外部 watch/computed 的意外改写
3. **z-index 分层策略**：组合置于成员下方，配合空白命中测试实现"子组件优先、空白选组合"
4. **相对偏移保持**：批量粘贴时以第一个为锚点记录偏移，确保多组件布局不变形
5. **同步变换传递**：组合拖拽/缩放时，遍历子组件同步应用位置/尺寸变换，保持内部结构一致
