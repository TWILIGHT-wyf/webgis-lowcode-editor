# deck.gl 使用教程（基于本仓库 Vue3 + TS + Vite + MapLibre）

本文面向本项目的实际集成，教你在 `mapView.vue` 中用 deck.gl 叠加高性能可视化图层，并给出常用图层、交互、性能与排错要点。

## 1. 快速上手（已在本仓库落地）

- 依赖（PowerShell 注意 @scope 需要用 `--%` 关闭解析）
  - 已安装：`@deck.gl/*`、`maplibre-gl`、`@types/geojson`
- 关键文件
  - `src/lib/deckgl/overlay.ts`：封装 MapboxOverlay（与 MapLibre 绑定），统一 tooltip
  - `src/lib/deckgl/layers/demo.ts`：ScatterplotLayer 示例工厂
  - `public/data/points.geojson`：示例点数据
  - `src/pages/mapView.vue`：底图 + deck.gl 集成页面

使用方式摘要（节选自 `mapView.vue`）：

```ts
import maplibregl from 'maplibre-gl'
import type { FeatureCollection, Point } from 'geojson'
import { createOverlay } from '@/lib/deckgl/overlay'
import { demoScatterLayer } from '@/lib/deckgl/layers/demo'

// 初始化 MapLibre
const map = new maplibregl.Map({
  container: el,
  style: 'https://demotiles.maplibre.org/style.json',
  center: [118.796877, 32.060255],
  zoom: 11,
})

// 加载 GeoJSON 并创建 deck.gl 图层 + 叠加到 MapLibre 控件
const fc = (await (await fetch('/data/points.geojson')).json()) as FeatureCollection<Point>
const overlay = createOverlay([demoScatterLayer(fc)])
map.addControl(overlay as unknown as maplibregl.IControl)
```

## 2. 常用图层一览（入门优先顺序）

- 点：`ScatterplotLayer`（本项目已示例）
- 线/面：`GeoJsonLayer`（道路、行政区、面填充）
- 聚合：`GridLayer`、`HexagonLayer`、`ScreenGridLayer`
- 瓦片：`TileLayer` + `MVTLayer`（矢量瓦片）
- 3D/地形：`TerrainLayer`、`Tile3DLayer`（进阶）

示例：GeoJsonLayer（线/面）

```ts
import { GeoJsonLayer } from '@deck.gl/layers'

export function geoLayer(geojson: any) {
  return new GeoJsonLayer({
    id: 'geojson',
    data: geojson,
    stroked: true,
    filled: true,
    lineWidthUnits: 'pixels',
    getLineWidth: 1,
    getLineColor: [60, 120, 200, 200],
    getFillColor: [80, 160, 240, 80],
    pickable: true,
  })
}
```

示例：MVT 瓦片（搭配开源样式）

```ts
import { TileLayer } from '@deck.gl/geo-layers'
import { MVTLayer } from '@deck.gl/geo-layers'

export function mvtLayer() {
  return new TileLayer({
    id: 'mvt',
    data: 'https://tile.nextzen.org/tilezen/vector/v1/512/all/{z}/{x}/{y}.mvt?api_key=your_key',
    minZoom: 0,
    maxZoom: 14,
    tileSize: 512,
    renderSubLayers: (props) => {
      const {
        bbox: { west, south, east, north },
        data,
      } = props
      return new MVTLayer(props, {
        data,
        getLineColor: [30, 144, 255],
        getFillColor: [30, 144, 255, 40],
        lineWidthMinPixels: 1,
        pickable: true,
        bounds: [west, south, east, north],
      })
    },
  })
}
```

## 3. 交互与 tooltip（picking）

- 开启拾取：图层上设置 `pickable: true`
- tooltip：可在 Overlay 层使用 `getTooltip` 统一返回文本/HTML
- 选中/高亮：可用 `getLineColor/getFillColor` 根据选中 id 改变颜色，结合 `updateTriggers` 控制增量更新

本项目 Overlay 封装（摘自 `overlay.ts`）：

```ts
import { MapboxOverlay } from '@deck.gl/mapbox'
export function createOverlay(layers = []) {
  return new MapboxOverlay({
    interleaved: true,
    layers,
    getTooltip: ({ object }) => {
      if (!object) return null
      const anyObj = object as Record<string, unknown> & { properties?: Record<string, unknown> }
      const props = anyObj.properties ?? anyObj
      const text = Object.entries(props)
        .slice(0, 4)
        .map(([k, v]) => `${k}: ${String(v)}`)
        .join('\n')
      return { text }
    },
  })
}
```

## 4. 性能要点（100k 点 60 FPS 的关键）

- 数据格式：尽量使用数组与扁平属性；需要时考虑列式（TypedArray）
- `updateTriggers`：只在依赖变更时重算 accessor，避免全量刷新
- LOD 策略：根据 zoom/范围切换不同密度数据（聚合 vs 散点）
- GPU 聚合：优先使用 `GridLayer/ScreenGridLayer/HexagonLayer`
- Worker：将计算型逻辑（聚合/筛选）迁移到 Web Worker，主线程仅负责渲染
- 降级：低端设备降采样、简化样式、关闭阴影/抗锯齿

例：在图层上声明 `updateTriggers`

```ts
new ScatterplotLayer({
  getRadius: (f) => 80 + f.properties.value * 5,
  updateTriggers: { getRadius: [dataVersion] },
})
```

## 5. 与 MapLibre 同步视图

- 使用 `@deck.gl/mapbox` 的 `MapboxOverlay` 将 deck.gl 作为一个控件添加到 MapLibre
- 好处：自动同步缩放、旋转、中心；减少手工维护的复杂度
- 注意：`map.addControl(overlay)` 时类型可能不完全匹配，可使用临时断言

## 6. 常见问题与排错

- PowerShell 无法安装 `@scope` 包：使用 `--%` 关闭解析或为包名加引号
- MapLibre `attributionControl` 类型：v5 中该字段为 `false|AttributionControlOptions`，不要直接写 `true`
- Axios Headers 类型：不要把 `config.headers` 赋值为普通对象，优先使用 `new AxiosHeaders()` 或 `set()`
- build 时出现 `spawn is not exported by __vite-browser-external`：来自 loaders.gl 的 worker-utils 在浏览器构建下的警告，一般不影响；如需彻底清理可通过 `optimizeDeps`/`ssr.noExternal` 或版本匹配优化（非必需）

## 7. 进阶：聚合、瓦片与 Worker

- 聚合（大数据首选）
  - `GridLayer`/`ScreenGridLayer`（2D 网格）、`HexagonLayer`（蜂窝格）
  - 在缩放较低时用聚合，缩放较高时切换为散点（阈值可配置）
- 瓦片（按需加载）
  - `TileLayer + MVTLayer` 可按 z/x/y 加载矢量瓦片，减少一次性传输的数据量
- Worker（耗时计算）
  - 将筛选/统计/聚合放入 Web Worker（如使用 `comlink` 简化通信），主线程只接收结果并更新图层

## 8. TypeScript 小贴士

- 为 GeoJSON 提供类型：`@types/geojson` 已安装
- 图层数据类型：`ScatterplotLayer<Feature<Point, Properties>>` 明确 feature 类型
- 少用 `any`：封装属性读取函数（见 `propValue`）来规避空值/类型不明

## 9. 验收与测试建议

- 手测：首屏渲染是否流畅；缩放/拖拽无明显掉帧；hover 有 tooltip
- 单测（Vitest）：对数据到属性映射的纯函数（如 `propValue`）做 2–3 条用例
- e2e（Playwright）：页面载入后 deck.gl canvas 可见、tooltip 能出现

## 10. 下一步（对应项目里程碑）

- M1：图层面板（显示/隐藏、透明度）+ GeoJsonLayer（线/面）示例
- M2：10k/100k 点合成数据与聚合层，加入性能 HUD（FPS/P95）
- M3：圈选（brush/矩形）+ Turf 空间过滤 + 导出 CSV/JSON；考虑迁移计算到 Worker

> 如需我继续：
>
> 1. 生成 10k/100k 合成点数据脚本；2) 加一个最简图层面板并接入 `mapView.vue`；3) 增加 1 条 e2e 骨架测试。
