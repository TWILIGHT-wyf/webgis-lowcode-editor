# 2025-11-04 技术难点汇总

> 今日主要围绕「画布缩放/平移交互」与「UI 显示」展开，梳理关键原理、常见坑与可行修复方案。

## 1) 百分比显示与双向绑定

- 需求：scale 的内部值是 0~1 的小数，但希望在输入框中以 0~100 的百分比展示/编辑。
- 方案：用 computed 做映射（get: scale\*100 四舍五入；set: 百分比/100 回写）。
- 元件限制：Element Plus 的 `el-input-number` 不内置显示单位（没有 suffix/formatter 插槽），因此不要指望直接显示“%”；常见做法是在输入框后面放一个“%”文本，或换用 `el-input` + suffix 槽。

示例（核心逻辑）：

```ts
const scalePercent = computed({
  get: () => Math.round((scale.value ?? 0) * 100),
  set: (val: number) => {
    const n = Number(val)
    if (!Number.isNaN(n)) scale.value = n / 100
  },
})
```

## 2) 滚轮缩放（wheel）

- 使用标准 `wheel` 事件，并在监听时设置 `{ passive: false }`，以便 `e.preventDefault()` 生效。
- 建议按住 Ctrl 才触发缩放，避免与页面默认滚动冲突（可选）。
- 平滑因子：`factor = Math.pow(1.0015, ±e.deltaY)`，指数映射能兼容鼠标与触控板的不同增量。
- 缩放范围限制：例如 10%~500%（0.1~5）。
- 方向约定：若希望“下滚缩小、上滚放大”，使用 `Math.pow(1.0015, -e.deltaY)` 或在结果上取倒数来调整方向。

示意：

```ts
function clamp(n: number, min: number, max: number) {
  return Math.min(max, Math.max(min, n))
}

function onWheel(e: WheelEvent) {
  // if (!e.ctrlKey) return // 可选：仅按住 Ctrl 时缩放
  e.preventDefault()
  const factor = Math.pow(1.0015, -e.deltaY) // 下滚缩小、上滚放大
  scale.value = clamp(scale.value * factor, 0.1, 5)
}
```

## 3) 拖拽平移（pan）

- 状态：`panX/panY` 表示视觉平移偏移；用 CSS `transform` 实现（合成层，性能好）。
- 流程：`mousedown` 记录起点（`e.clientX/Y`）与起始偏移；`mousemove` 用位移增量更新 `panX/Y`；`mouseup` 清理监听。
- 坐标：`e.clientX/Y` 是相对于视口的像素坐标，不受页面滚动影响；更稳定于本场景。

示意：

```ts
let startX = 0,
  startY = 0,
  startPanX = 0,
  startPanY = 0
function onPanStart(e: MouseEvent) {
  if (e.button !== 0) return
  startX = e.clientX
  startY = e.clientY
  startPanX = panX.value
  startPanY = panY.value
  window.addEventListener('mousemove', onPanMove)
  window.addEventListener('mouseup', onPanEnd)
}
function onPanMove(e: MouseEvent) {
  panX.value = startPanX + (e.clientX - startX)
  panY.value = startPanY + (e.clientY - startY)
}
function onPanEnd() {
  window.removeEventListener('mousemove', onPanMove)
  window.removeEventListener('mouseup', onPanEnd)
}
```

## 4) 分层架构与 transform 顺序

- 分层职责：
  - wrap：视口容器，`overflow: hidden` 负责裁剪与承载事件。
  - world：承载“平移+缩放”的 transform。
  - stage：仅用逻辑尺寸（width/height），不跟随 transform 改变自身布局；内部组件坐标保持逻辑值。
- 变换顺序：CSS transform 从右到左应用。为了“平移像素不随缩放改变”，推荐写法：

```css
/* 先应用 scale，再应用 translate → 写成 translate(...) scale(...) */
transform: translate(var(--pan-x), var(--pan-y)) scale(var(--scale));
transform-origin: 0 0;
```

## 5) 为什么之前看起来被“限制/卡住”

- 若把“缩放”做成修改 DOM 宽高（`width * scale`），会触发布局，且可能受父容器尺寸（100%/flex/max-\*）约束，看起来像被“限制”。
- 改为 world 层 `transform: scale` 后，缩放不参与布局，父容器只做裁剪，就不会被“限制”。

## 6) 为什么 world 看起来“无限大”

- `transform` 不改变布局尺寸，`overflow: hidden` 只裁剪视口；加上无限的背景网格，视觉上像“无边界”。
- 解决：给 pan 加边界，小于视口时自动居中，缩放后纠正 pan。

示意（边界计算）：

```ts
function calcPanBounds(viewW: number, viewH: number) {
  const contentW = width.value * scale.value
  const contentH = height.value * scale.value
  const minX = contentW <= viewW ? (viewW - contentW) / 2 : viewW - contentW
  const maxX = contentW <= viewW ? minX : 0
  const minY = contentH <= viewH ? (viewH - contentH) / 2 : viewH - contentH
  const maxY = contentH <= viewH ? minY : 0
  return {
    minX: Math.round(minX),
    maxX: Math.round(maxX),
    minY: Math.round(minY),
    maxY: Math.round(maxY),
  }
}
```

## 7) 坐标换算（屏幕点 → 舞台逻辑坐标）

按“先去平移、再除缩放”的逆变换：

```ts
function screenToStage(clientX: number, clientY: number, contentEl: HTMLElement) {
  const rect = contentEl.getBoundingClientRect()
  const xOnWorld = clientX - rect.left - panX.value
  const yOnWorld = clientY - rect.top - panY.value
  return { x: xOnWorld / scale.value, y: yOnWorld / scale.value }
}
```

## 8) 事件与兼容要点

- 推荐用 `wheel`（标准），如需拦截默认行为务必 `{ passive: false }`。
- 老事件 `mousewheel` 仅兼容兜底；`scroll` 不是拿增量的，不适合做缩放。
- 可考虑迁移到 Pointer 事件，统一鼠标/触控。

## 9) 后续优化清单（可选）

- 鼠标位置为锚点的缩放（缩放时补偿 pan，保证光标下内容不漂移）。
- 平移边界/居中逻辑抽成 util，监听窗口 resize 自适应。
- 提供重置视图（回到 100% 且居中）。
- 支持中键/空格键+拖拽等常见画布交互习惯。


