## 2025-11-10 画布拖拽改造：绝对坐标 + 锚点方案

### 背景与目标

- 画布存在平移和平移（panX/panY）与缩放（scale）的组合变换，直接用鼠标增量（dx/dy）叠加到组件坐标，容易在不同缩放下出现手感不一致或轻微漂移。
- 传统增量拖拽还会出现一个问题：按住组件中间拖动，元素会“吸附”到左上角（即脱离按下点），体验不好。

目标：

- 统一用“舞台坐标系（stage）”的绝对坐标更新组件位置，避免累积误差、缩放失真。
- 引入“锚点（anchor）”：记录鼠标在组件内部的相对偏移，确保拖拽过程中鼠标与组件的相对位置保持不变，不会跳。

### 核心思路（公式）

将屏幕坐标映射为舞台坐标：

- 设鼠标屏幕坐标为 $(c_x, c_y)$，根容器（canvas wrap）边界为 `rootRect.left/top`，画布平移为 $(\text{panX}, \text{panY})$，缩放为 $s$。
- 则舞台坐标为：

$$
  ext{mouseStageX} = \frac{c_x - \text{rootRect.left} - \text{panX}}{s},\quad
  ext{mouseStageY} = \frac{c_y - \text{rootRect.top} - \text{panY}}{s}
$$

锚点（在按下时记录）：

$$
  ext{anchorX} = \text{mouseStageX} - \text{elLeft},\quad
  ext{anchorY} = \text{mouseStageY} - \text{elTop}
$$

拖拽时实时位置：

$$
	ext{newX} = \text{mouseStageX} - \text{anchorX},\quad
	ext{newY} = \text{mouseStageY} - \text{anchorY}
$$

---

## 辅助线与吸附（对齐/旋转）实现总结

### 目标

- 拖拽时对齐到其他组件的边缘/中心线，网格对齐可选；显示对应的参考辅助线。
- 旋转时在常用角度（0/90/180/−90）或步进角（如 15°）附近吸附，Shift 启用步进、Alt 临时关闭吸附。

### 模块划分

- 算法：放在 `utils/snapMath.ts`（或 `composable/Editor/useSnap.ts` 内的纯函数）。
- 组合逻辑：`useSnap` 暴露 `snapMove/snapAngle` 与 `vGuide/hGuide/angleGuide`。
- 渲染：`SnapGuides.vue` 订阅 `vGuide/hGuide` 绘制参考线；与舞台同坐标系。
- 使用：`shape.vue` 在拖拽/旋转时调用 `snapMove/snapAngle`，再更新 store。

### 位置吸附算法（简要）

设当前矩形 `me={x,y,width,height}`，其它矩形数组 `others`；阈值 `T`，网格大小 `G`。

1. 组件间对齐：比较以下特征值的最近距离，若小于阈值则吸附：

- 水平：`left`、`centerX`、`right`
- 垂直：`top`、`centerY`、`bottom`

2. 网格吸附（可选）：

   $$
   	ext{gridX} = \operatorname{round}(x/G)\cdot G,\quad
   	ext{gridY} = \operatorname{round}(y/G)\cdot G
   $$

   若 `|gridX - x| <= T` 则取 `gridX`，`Y` 同理。

3. 输出：

- 最终位置 `(x', y')` 与可选的 `vGuide/hGuide`（用于画参考线）。

伪代码：

```
snapMove(me, others, T=6, G=20):
  x, y = me.x, me.y
  bestV = bestH = null
  # X: 与他们的 left/centerX/right 比较
  for myVal, offset in [(left,0),(centerX,w/2),(right,w)]:
    for tx in union(all others' [left,centerX,right]):
      if abs(myVal - tx) <= T: x = tx - offset; bestV = tx
  # Y: 与他们的 top/centerY/bottom 比较
  for myVal, offset in [(top,0),(centerY,h/2),(bottom,h)]:
    for ty in union(all others' [top,centerY,bottom]):
      if abs(myVal - ty) <= T: y = ty - offset; bestH = ty
  # 网格吸附
  if G>0:
    gx = round(x/G)*G; if |gx-x|<=T: x=gx; if bestV is null: bestV=gx
    gy = round(y/G)*G; if |gy-y|<=T: y=gy; if bestH is null: bestH=gy
  return { x, y, vGuide: bestV, hGuide: bestH }
```

### 旋转角度吸附（简要）

1. 归一化到 $[-180,180)$：`normalize(angle)`

2. 候选：

- 固定目标角度：如 `[0, 90, 180, -90]`
- 步进角（Shift 时启用）：`-180..180` 以 `step`（默认 15°）步进生成。

3. 选择最近候选：若角度差小于阈值（默认 5°），吸附到该候选；Alt 时直接返回原角度。

伪代码：

```
snapAngle(angle, targets=[0,90,180,-90], step=15, T=5, shift=false, alt=false):
  if alt: return normalize(angle)
  cand = normalize(targets)
  if shift: cand += [-180..180) every step
  a = normalize(angle)
  best = argmin_t(|normalize(a - t)|)
  if |a - best| <= T: return best else return a
```

### 性能与交互细节

- 位置更新：`mousemove` 使用 `throttle(16ms)`；对 store 写入 `debounce(30~50ms)`。
- 快捷键：`Shift` 开启角度步进；`Alt` 临时关闭吸附（位置与角度都可遵循）。
- 辅助线渲染：独立组件只读状态，`pointer-events: none`，避免遮挡交互。

### 放置结构建议

- 算法：`utils/snapMath.ts`
- 组合：`composable/Editor/useSnap.ts`（管理 vGuide/hGuide/angleGuide）
- 组件：`components/Editor/SnapGuides.vue`（专职绘制线）
- 入口：`shape.vue` 使用；`CanvasBoard.vue` 仅 provide 上下文并挂载 `SnapGuides`。

---

说明：`elLeft/elTop` 为组件当前在 stage 中的 `left/top`（不受 world transform 影响）。这样计算保证了：

- 不管缩放、平移如何变化，坐标更新都精准。
- 鼠标按住组件的哪个点，拖动过程中就保持那个点的相对位置，不会“跳到左上角”。

### 代码落点与改动

- `src/components/Editor/CanvasBoard.vue`
  - provide 根容器 ref：`provide('canvasWrapRef', wrap)`，用于统一坐标基准。
  - 网格背景改到 `.stage`，保证随缩放/平移一起变换（更自然）。

- `src/composable/useCanvasInteraction.ts`
  - 新增选项：`rootRefForAbs`（根容器 ref）。
  - 在拖拽开始时计算锚点 `anchorX/anchorY`：先把鼠标映射到 stage，再减去元素当前 `left/top`。
  - 在 `mousemove` 中用绝对坐标公式计算 `(newX, newY)` 后回调 `dragCallback(newX, newY)`。
  - 事件节流：`onDragMove` 使用 `throttle(..., 16ms)` 保持 ~60fps。

- `src/components/Editor/shape.vue`
  - 注入 `canvasWrapRef` 并通过 `rootRefForAbs` 传递给交互组合函数。
  - 在 `dragCallback` 中使用“绝对位置”直接更新 store；为避免高频 commit，加了 `debounce(50ms)`（可按体验调整）。

### 为什么比“增量位移”更稳

- 绝对坐标每次都从“真实鼠标位置”倒推，不会因为浮点误差或帧丢失而累计偏移。
- 锚点保证拖拽的起始相对关系，用户按住哪里就拖哪里，不会吸附到元素角点。
- 缩放和平移都被统一纳入映射公式，手感在任意 scale 下都一致。

### 性能与交互

- 节流（throttle 16ms）：限制鼠标移动处理频率，保证丝滑但不占满主线程。
- 防抖（debounce 50ms）：减少频繁写 store；如果觉得位置跟随有延迟感，可降到 30ms 或在拖拽中改为直接 set、在松手后再最终 commit。

### 已知边界与后续优化

- 旋转（rotation）场景：当前拖拽仍以包围盒的 `left/top` 为基准；若希望沿元素“本地轴”拖动，需要引入旋转矩阵变换（可后续增强）。
- 吸附网格：可在 `newX/newY` 最终写入前做网格量化（如 `round(x / grid) * grid`）。
- 多选/约束：支持按住修饰键限定轴向（仅 X 或 Y）、或多选同步移动。

### 小结

通过“绝对坐标 + 锚点”的组合，我们把拖拽从“相对增量累积”升级为“屏幕→舞台的一次性映射”，辅以节流/防抖控制，最终得到：

- 缩放/平移无关的稳定手感；
- 按住哪里拖哪里的不跳动体验；
- 清晰的数学模型，便于扩展吸附、对齐、旋转本地轴拖拽等高级能力。
