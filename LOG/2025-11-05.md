# 2025-11-05 技术难点汇总

> 今日主要围绕「低代码平台实现」展开，涵盖画布交互、组件管理、注册与类型系统。梳理关键原理、常见坑与可行修复方案。

## 1) 低代码组件编写原则

- **运行态 vs 设计态**：运行态组件纯展示/可控（props 注入、v-model 双向绑定），设计态由画布负责选中/拖拽/缩放。
- **可序列化**：所有 props/样式/事件通过外部注入，无内部状态持久化。
- **单一数据源**：优先 v-model（modelValue + update:modelValue），支持表达式绑定。
- **元数据驱动**：用 meta 描述属性/事件/插槽/默认值/分组/图标/可拖拽等。
- **样式可控**：样式走 props（内联或 CSS 变量），避免硬编码。

示例（最小 Vtext.vue）：

```vue
<template>
  <component :is="tag" :style="textStyle" @click="$emit('click')">
    {{ modelValue }}
  </component>
</template>
<script setup lang="ts">
const props = withDefaults(defineProps<{ modelValue: string; tag?: string }>(), { tag: 'div' })
const emit = defineEmits<{ 'update:modelValue': [val: string]; click: [] }>()
const textStyle = computed(() => ({ color: props.color, fontSize: props.fontSize + 'px' }))
</script>
```

## 2) Schema 到代码生成原理

- **核心工件**：物料（组件+meta）、Schema（JSON 树）、渲染器（运行时解释）、导出器（代码生成）。
- **Schema 结构**：节点含 type/props/style/events/children/slots/condition/loop。
- **运行时渲染**：registry[type] → 组件，沙箱 eval 表达式，动作解释器执行 DSL。
- **代码生成**：模板拼接（EJS）或 AST 生成（@babel/types），编译为 SFC/路由/状态/服务源码。
- **事件 DSL**：setState/request/condition/branch → 函数或 async 流程。

## 3) 侧边栏物料面板实现

- **拖拽 vs 点击**：用 draggable="true" 的 div，支持拖到画布添加；点击快速添加。
- **结构**：el-collapse 分组，palette-list 网格布局，palette-item 卡片样式。
- **交互**：dragstart 设置 dataTransfer（application/x-component），画布 drop 解析添加。

## 4) 拖拽添加组件

- **原理**：dragstart 传递物料 info，drop 解析并计算投放位置（去平移/除缩放）。
- **数据传输**：用 Pinia 数组存储 ComponentInstance（id/type/props/style/position/size）。
- **渲染**：`<component :is="getComponent(comp.type)" v-bind="comp.props" :style="...">`。

## 5) 组件注册表与动态渲染

- **注册表**：放在 registry.ts（Record<string, Component>），映射 type 到组件构造函数。
- **动态组件**：`<component :is="getComponent(comp.type)">`，支持运行时切换类型。
- **位置**：不放在 Pinia（静态配置），放在单独文件便于扩展。

## 6) 组件名警告（vue/multi-word-component-names）

- **原因**：ESLint 要求组件名多个词（如 VText 而非 Text）。
- **忽略方法**：
  - 文件级：`// eslint-disable-next-line vue/multi-word-component-names`
  - 项目级：在 .eslintrc.js 中 `'vue/multi-word-component-names': 'off'`
- **推荐**：重命名为多词名，避免忽略。

## 7) .vue 类型声明与导入报错

- **报错原因**：TS 找不到 .vue 模块类型。
- **修复**：在 env.d.ts 或 shims-vue.d.ts 中添加：
  ```ts
  declare module '*.vue' {
    import type { DefineComponent } from 'vue'
    const component: DefineComponent<{}, {}, any>
    export default component
  }
  ```
- **组件类型**：用 `Component`（通用）而非 `DefineComponent`（需指定 props）。

## 8) el-text 组件封装

- **用途**：Element Plus 的 el-text 支持 size/type/truncated/lineClamp。
- **编辑模式**：用 contenteditable div，支持内联编辑。
- **v-model**：双向绑定文本，支持 update:modelValue。

## 9) Pinia 管理组件数组

- **接口**：ComponentInstance 含 id/type/props/style/position/size。
- **方法**：addComponent/removeComponent/updateComponentProps/updateComponentPosition 等。
- **选中**：selectedId ref，用于属性面板绑定。

## 10) 坐标换算与画布交互

- **屏幕到逻辑**：(clientX - rect.left - panX) / scale，(clientY - rect.top - panY) / scale。
- **平移边界**：内容小于视口时居中，否则限制在 [min, max]。
- **缩放居中**：可选按鼠标位置补偿 panX/panY。

## 11) 其他扩展

- **表达式沙箱**：Proxy 限制上下文，防注入。
- **动作编排**：DSL 支持 setState/request/condition，编译为函数。
- **数据源**：REST/GraphQL 配置，生成 typed 服务。
- **导出工程**：生成 package.json/tsconfig/vite.config，收集依赖。

## 今日问题与解决（实战）

- 拖拽数据如何传输
  - 在侧边栏 dragstart：`e.dataTransfer.setData('application/x-component', JSON.stringify(item))`，兜底再写入 `text/plain`。
  - 在画布 drop：`const data = e.dataTransfer?.getData('application/x-component')` → `JSON.parse(data)` 获得物料信息。

- 投放位置为什么有误差、如何计算
  - 误差来源：使用 `e.target.getBoundingClientRect()` 时，target 可能是 world 或 stage，基准不一致。
  - 修复：固定用 `wrap.getBoundingClientRect()`（或固定用 stageRect，但要一致）。
  - 公式（相对于舞台的逻辑坐标）：
    ```ts
    const wrapRect = wrap.value!.getBoundingClientRect()
    const x = (e.clientX - wrapRect.left - panX.value) / scale.value
    const y = (e.clientY - wrapRect.top - panY.value) / scale.value
    ```

- 组件位置贴左边/不生效
  - 原因：`position` 拼写错误（写成 postion）、或把 `top` 写成了 `right`。
  - 修复：确保样式为：
    ```ts
    { position: 'absolute', left: x + 'px', top: y + 'px' }
    ```
  - 父级 `stage` 需 `position: relative`，否则绝对定位会找错参照。

- 为什么拖到 world 正确、拖到 stage 有误差
  - 因为以不同元素的 rect 作为基准计算，导致偏移不同。
  - 统一用 `wrapRect`（推荐）或 `stageRect`，并一律“减平移 / 除缩放”。
  - world 只承载 transform（平移/缩放），业务组件应渲染在 stage 内。

- transform 顺序与重复缩放
  - 写法必须是：`transform: translate(px, py) scale(s)`（应用顺序先 scale 再 translate，平移像素不受缩放影响）。
  - 避免“双重缩放”：要么在 world 上 transform: scale，要么改 stage DOM 宽高乘以 scale（二者只能选一个）。

- 滚轮缩放细节
  - `wheel` 监听需 `{ passive: false }` 才能 `preventDefault()`。
  - 方向：`Math.pow(1.0015, -e.deltaY)` 实现“下缩小，上放大”。
  - 范围限制：`clamp(scale * factor, 0.1, 5)`。
  - “看起来无限大”的原因：transform 不参与布局 + overflow: hidden 只裁剪；如需边界，用内容尺寸与视口比计算 pan 限制并居中。

- 百分比显示（scale 0~1 显示为 0~100）
  - 用 computed 做映射；`el-input-number` 不带单位，可在后面放一个 `%` 文本或改用 `el-input` 的 suffix。

- 动态组件与注册表
  - 用 `<component :is="getComponent(type)">` 渲染不同物料。
  - 注册表独立放在 `registry.ts`，不要放 Pinia；类型用 `Record<string, Component>`。
  - 需要 `.vue` 模块声明（在 `env.d.ts` 或 `shims-vue.d.ts`）：
    ```ts
    declare module '*.vue' {
      import type { DefineComponent } from 'vue'
      const component: DefineComponent<{}, {}, any>
      export default component
    }
    ```

- 组件名必须多词的警告
  - 重命名为多词（如 `VText`），或在 ESLint 配置里关闭 `vue/multi-word-component-names`，或在文件顶部加忽略注释（单文件）。

- 样式类型
  - `style` 建议用 `CSSProperties`（`import type { CSSProperties } from 'vue'`），比 `object`/`any` 更安全。

- 公式推导（为何要“减平移/除缩放”）
  - 视觉坐标满足：`visualX = panX + logicalX * scale` → 解得 `logicalX = (visualX - panX) / scale`。
  - 用 `visualX = e.clientX - wrapRect.left` 把屏幕坐标换算到视口内。

—— 以上为今日实际遇到的问题与对应修复方案，后续可把“鼠标点为锚点的缩放补偿”和“平移边界/居中”抽成 util，便于复用。
