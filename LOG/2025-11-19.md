# 2025-11-19 开发日志

## 主题 1：低代码平台代码生成方案设计

### 核心问题

探讨如何将画布中的组件（componentStore）生成可部署的运行态代码，确定了**循序渐进**的实现策略。

### 技术方案

#### 阶段一：单页面代码生成（当前优先级）

**1. Store 扩展 - 页面管理**

- 新增 `usePage` store，支持多页面管理
- 每个页面包含：
  - 基础信息：id、name、path、title
  - 组件列表：components[]
  - 元数据：meta（权限、缓存、图标等）
  - 全局状态：globalState（页面级变量）
  - 生命周期事件：onLoad、onUnload

**2. 组件 Store 改造**

- `componentStore` 改为计算属性，动态绑定到当前页面
- `addComponent` 等操作自动关联到当前激活页面
- 实现页面间组件隔离

**3. 代码生成器实现**

创建 `src/utils/codegen.ts`：

- `generatePageSFC(page)` - 生成运行态 Vue 单文件组件
  - 过滤 Group 占位容器
  - 内嵌组件数据为 JSON 字面量
  - 自动处理样式、动画、数据源
  - 支持轮询数据获取
  - 生命周期钩子集成

- `generatePageRestoreScript(page)` - 生成编辑态恢复脚本
  - 通过 addComponent API 重建画布
  - 可在开发环境执行恢复页面状态

- `downloadText(filename, content)` - 浏览器下载工具

**4. UI 集成**

- 在 `header.vue` 添加"导出代码"下拉菜单
- 支持导出当前页面为 .vue 文件
- 支持导出编辑态恢复脚本 .ts

#### 阶段二：多页面管理（下一步）

**功能规划**

- 页面管理面板：新增/删除/切换页面
- 页面列表展示：标题、路径、组件数量
- 页面切换时自动加载对应组件
- 限制至少保留一个页面

**实现要点**

- 创建页面管理对话框组件
- 集成到主界面工具栏
- 支持页面元数据编辑

#### 阶段三：页面间联动（中期目标）

**待实现功能**

- 全局状态管理（Pinia store 跨页面共享）
- 页面跳转事件与参数传递
- URL 查询参数解析
- 组件间通信机制

#### 阶段四：完整项目脚手架生成（最终目标）

**生成内容**

- 完整的 Vite + Vue3 + TypeScript 项目结构
- package.json 及依赖配置
- 路由配置（Vue Router）
- 所有页面的 SFC 文件
- 构建配置与 README
- 打包为 .zip 下载

**技术依赖**

- jszip - 生成 ZIP 压缩包
- file-saver - 浏览器下载

### 关键技术点

#### 1. 数据源处理

- 保留 `component.dataSource` 配置
- 运行态自动启动轮询（基于 interval）
- 支持 REST API 数据获取
- dataPath 表达式提取嵌套数据

#### 2. 动画系统

- `animation.class` 自动应用到运行态组件
- 动画参数转换为 CSS 属性：duration、delay、iterationCount、timingFunction
- 依赖 `src/styles/animations.css` 全局样式

#### 3. 组件注册

- 依赖 `src/customComponents/registry.ts` 的 `getComponent` 函数
- 动态组件渲染：`<component :is="getComponent(type)">`
- 需确保所有组件类型已注册

#### 4. 样式计算

- 绝对定位：position、left、top
- 尺寸：width、height
- 旋转：transform rotate
- 透明度：opacity (百分比转小数)
- 可见性：visible 控制 visibility
- 锁定：locked 控制 pointerEvents

### 实现优先级

```
✅ 当前：单页面 SFC 生成 + 恢复脚本
🔄 近期：页面管理面板 + 多页面切换
🎯 中期：页面间状态共享 + 路由跳转
🚀 长期：完整项目脚手架 + 一键部署
```

### 开发建议

1. **先完成阶段一和阶段二**，确保基础功能稳定
2. **逐步验证**：每个阶段产出可用的代码生成能力
3. **降低复杂度**：避免一次性实现所有功能
4. **保持灵活性**：为后续扩展预留接口

### 待办事项

- [ ] 实现 `src/stores/page.ts` - 页面管理 Store
- [ ] 实现 `src/utils/codegen.ts` - 代码生成工具
- [ ] 实现 `src/utils/download.ts` - 下载工具
- [ ] 修改 `src/stores/component.ts` - 绑定到页面
- [ ] 修改 `src/components/header.vue` - 添加导出按钮
- [ ] 创建页面管理对话框组件
- [ ] 测试单页面导出功能
- [ ] 测试编辑态恢复脚本

### 参考文件

- `src/stores/component.ts` - 组件状态管理
- `src/components/componentBar.vue` - 组件面板
- `src/components/Editor/canvasBoard/canvasBoard.vue` - 画布渲染
- `src/customComponents/registry.ts` - 组件注册表
- `src/customComponents/text/Text.vue` - 组件示例
- `src/styles/animations.css` - 动画样式

### 技术收获

- 低代码平台的渐进式架构设计思路
- Vue3 动态组件渲染模式
- 代码生成器的模板字符串构建技巧
- 浏览器端文件下载实现
- 多页面状态隔离与共享策略

## 2025-11-19 下午：布局容器 Row 组件实现

### 完成工作

#### 1. Row 组件核心实现 (`src/customComponents/layout/row/row.vue`)

**功能特性**

- **子组件渲染**：通过 `children` 数组动态渲染子组件，支持嵌套布局
- **样式配置**：完整的 CSS 样式支持，包括背景、边框、圆角、内边距、外边距
- **Flexbox 布局**：支持 `flexDirection`、`justifyContent`、`alignItems`、`flexWrap`、`gap` 等布局属性
- **响应式设计**：移动端自动切换为列布局
- **数据源集成**：支持远程数据获取（预留接口）
- **动画支持**：自动应用子组件的动画类

**技术实现**

- 使用 `<component :is="getComponent(type)">` 动态渲染子组件
- 通过 `v-for` 遍历 `children` 数组渲染所有子组件
- 子组件使用相对定位，坐标相对于 Row 容器
- 完整的 TypeScript 类型支持

#### 2. 组件注册与配置

**注册表更新** (`src/customComponents/registry.ts`)

```typescript
export const componentRegistry: Record<string, Component> = {
  Text: Text,
  Group: Group,
  Row: Row, // 新增 Row 组件注册
}
```

**默认属性配置** (`src/stores/component.ts`)

- 添加 Row 组件的默认 props，包括布局、样式、间距等配置
- 默认 flexDirection: 'row'，支持水平布局
- 默认最小高度 50px，可配置

**组件面板集成** (`src/components/componentBar.vue`)

- 在"布局容器"分类中添加 Row 组件
- 设置默认尺寸：400x120
- 类型统一为 'Row'

#### 3. 组件接口设计

**Props 支持**

- 背景样式：backgroundColor, backgroundImage, backgroundSize, backgroundPosition, backgroundRepeat
- 边框样式：borderWidth, borderStyle, borderColor, borderRadius
- 间距控制：paddingTop/Right/Bottom/Left, marginTop/Right/Bottom/Left
- Flexbox 属性：flexDirection, justifyContent, alignItems, flexWrap, gap
- 其他：minHeight, overflow, boxShadow

**子组件管理**

- 通过 `children: string[]` 管理子组件 ID 列表
- 自动计算子组件相对位置和样式
- 支持子组件的独立配置（样式、动画、数据源）

### 技术要点

#### 1. 动态组件渲染

```vue
<component
  v-for="childId in children"
  :key="childId"
  :is="getComponent(getChildType(childId))"
  :id="childId"
  :style="getChildStyle(childId)"
  v-bind="getChildProps(childId)"
  :class="getChildAnimation(childId)?.class"
/>
```

#### 2. 样式计算逻辑

- 容器样式：基于 props 计算完整的 CSS 属性
- 子组件样式：相对定位 + 独立尺寸和变换
- 响应式：CSS 媒体查询自动适配

#### 3. 类型安全

- 完整的 TypeScript 接口定义
- 编译时类型检查
- 与现有组件系统完全兼容

### 使用方式

**在编辑器中**

1. 从组件面板的"布局容器"分类中拖拽"行"组件到画布
2. 调整 Row 组件的样式和布局属性
3. 将其他组件拖拽到 Row 容器内作为子组件
4. 子组件会自动相对于 Row 容器定位

**代码生成**

- Row 组件会包含在导出的 SFC 和恢复脚本中
- 子组件关系通过 `children` 数组保持
- 支持嵌套布局结构

### 后续扩展

- **Column 组件**：垂直布局容器
- **Grid 组件**：网格布局容器
- **Tabs 组件**：选项卡布局
- **嵌套支持**：Row 中包含其他 Row 组件
- **拖拽排序**：子组件在容器内的排序调整

### 验证状态

- ✅ 组件创建和注册完成
- ✅ 默认属性配置完成
- ✅ 组件面板集成完成
- ✅ 代码生成集成（继承现有逻辑）
- 🔄 运行时测试（待 UI 验证）
- 🔄 嵌套布局测试（待功能验证）

### 技术收获

- Vue3 动态组件的高级用法
- Flexbox 布局在组件化中的应用
- 低代码平台中容器组件的设计模式
- TypeScript 在复杂组件中的类型管理
- 组件注册表的可扩展架构设计

---

## 主题 2：lineChart 图表组件数据源增强

### 需求背景

用户指出原有数据源配置过于笼统，后端返回的数据通常是嵌套结构，需要能够分别指定：

- 图表数据值的路径（如 `readings.temperatures`）
- X 轴标签的路径（如 `readings.timestamps`）
- 系列名称的路径（可选）

### 实现内容

#### 1. 数据源 Schema 扩展

**文件：** `src/components/siderBar/properties/properties.ts`

为 `lineChart` 类型添加专用数据源字段：

```typescript
case 'lineChart':
  return [
    { key: 'enabled', label: '启用数据源', type: 'switch' },
    { key: 'url', label: 'API 地址', type: 'text',
      placeholder: 'http://localhost:3001/api/chart/nested' },
    { key: 'method', label: '请求方法', type: 'select',
      options: ['GET', 'POST'] },
    { key: 'interval', label: '自动刷新(秒)', type: 'number' },
    { key: 'dataPath', label: '数据值路径', type: 'text',
      placeholder: '例: data.chart.values 或 readings.temperatures' },
    { key: 'xAxisPath', label: 'X轴标签路径', type: 'text',
      placeholder: '例: data.chart.categories 或 readings.timestamps' },
    { key: 'seriesNamePath', label: '系列名称路径', type: 'text',
      placeholder: '例: data.seriesName (可选)' },
    { key: 'headers', label: '请求头(JSON)', type: 'text' },
  ]
```

#### 2. DataSource 类型定义更新

**文件：** `src/stores/component.ts`

```typescript
export interface DataSource {
  enabled: boolean
  url: string
  method: 'GET' | 'POST' | 'PUT' | 'DELETE'
  headers?: Record<string, string>
  body?: string
  interval?: number
  dataPath?: string
  xAxisPath?: string // 用于图表的 X 轴标签路径
  seriesNamePath?: string // 用于图表的系列名称路径
  [key: string]: unknown
}
```

默认数据源配置：

```typescript
case 'lineChart':
  return {
    enabled: false,
    url: '',
    method: 'GET',
    headers: {},
    interval: 0,
    dataPath: '',
    xAxisPath: '',
    seriesNamePath: '',
  }
```

#### 3. lineChart 组件改造

**文件：** `src/customComponents/chart/lineChart/lineChart.vue`

**核心改动：**

1. **引入数据源 Hook**

```typescript
import { useDataSource } from '@/datasource/useDataSource'

const { data: remoteData } = useDataSource(computed(() => comp.value?.dataSource))
```

2. **路径解析工具函数**

```typescript
function getValueByPath(obj: unknown, path: string): unknown {
  if (!path || !obj) return undefined
  try {
    const keys = path.replace(/\[(\d+)\]/g, '.$1').split('.')
    let result: unknown = obj
    for (const key of keys) {
      if (result === null || result === undefined) return undefined
      result = (result as Record<string, unknown>)[key]
    }
    return result
  } catch {
    return undefined
  }
}
```

3. **数据优先级处理**

在 `buildSimpleOption()` 中：

```typescript
let data: number[] = [150, 230, 224, 218, 135, 147, 260]
let xAxisData: string[] = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
let seriesName: string = (p.seriesName as string) || 'Series'

// 如果数据源启用且有数据，优先使用数据源
if (ds?.enabled && remoteData.value) {
  // 提取数据值
  if (ds.dataPath) {
    const extractedData = getValueByPath(remoteData.value, ds.dataPath)
    if (Array.isArray(extractedData)) {
      data = extractedData.map((v) => (typeof v === 'number' ? v : parseFloat(String(v))))
    }
  }

  // 提取 X 轴标签
  if (ds.xAxisPath) {
    const extractedXAxis = getValueByPath(remoteData.value, ds.xAxisPath)
    if (Array.isArray(extractedXAxis)) {
      xAxisData = extractedXAxis.map((v) => String(v))
    }
  }

  // 提取系列名称
  if (ds.seriesNamePath) {
    const extractedName = getValueByPath(remoteData.value, ds.seriesNamePath)
    if (extractedName) {
      seriesName = String(extractedName)
    }
  }
} else {
  // 使用手动输入的数据（逗号分隔或 JSON）
  if (p.dataInput) {
    data = parseDataInput(p.dataInput as string)
  } else if (p.data) {
    data = p.data as number[]
  }

  if (p.xAxisInput) {
    xAxisData = parseXAxisInput(p.xAxisInput as string)
  } else if (p.xAxisData) {
    xAxisData = p.xAxisData as string[]
  }
}
```

4. **响应式监听增强**

```typescript
watch(
  [() => comp.value?.props, () => comp.value?.dataSource, remoteData],
  () => {
    chartOption.value = buildOption()
  },
  { deep: true, immediate: true },
)
```

#### 4. Mock 测试 API 扩展

**文件：** `test/mockServer.mjs`

新增 7 个图表测试 API，模拟真实场景的嵌套数据结构：

1. **简单图表** - `/api/chart/simple`

   ```json
   { "chartData": [65, 59, 80], "labels": ["Jan", "Feb", "Mar"] }
   ```

2. **嵌套图表** - `/api/chart/nested`

   ```json
   { data: { chart: { values: [...], categories: [...] } } }
   ```

3. **实时动态图** - `/api/chart/realtime` (2秒变化)

   ```json
   { result: { series: [...], xAxis: [...], timestamp: ... } }
   ```

4. **温度监控图** - `/api/chart/temperature` (3秒变化)

   ```json
   { readings: { temperatures: [...], timestamps: [...] } }
   ```

5. **服务器监控（CPU）** - `/api/chart/server`

   ```json
   { metrics: { cpu: [...], memory: [...], time: [...] } }
   ```

6. **用户活跃度** - `/api/chart/users`

   ```json
   { analytics: { activeUsers: [...], weeks: [...] } }
   ```

7. **股票价格** - `/api/chart/stock` (5秒变化)
   ```json
   { quote: { prices: [...], times: [...] } }
   ```

### 使用示例

**配置数据源：**

1. 在属性面板启用数据源
2. 填写 API 地址：`http://localhost:3001/api/chart/nested`
3. 设置数据值路径：`data.chart.values`
4. 设置 X 轴路径：`data.chart.categories`
5. 可选设置刷新间隔（如 3 秒）

**测试流程：**

```bash
# 启动 mock server
cd test
node mockServer.mjs

# 访问 http://localhost:3001
# 可看到完整的 API 文档和路径示例
```

### 技术亮点

1. **灵活的路径解析**：支持点号和数组索引（如 `data.items[0].name`）
2. **数据优先级**：数据源 > 手动输入 > 默认值
3. **类型安全**：完整的 TypeScript 类型定义
4. **响应式更新**：数据源变化自动刷新图表
5. **向后兼容**：保留原有手动输入方式

### 待优化点

- [ ] 考虑添加数据转换函数（如单位换算）
- [ ] 支持多系列图表的数据路径配置
- [ ] 添加数据验证与错误提示
- [ ] 优化属性面板的路径输入体验（智能提示？）
